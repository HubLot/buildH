#!/usr/bin/env pythonimport numpy as npimport pandas as pdimport dic_lipids"""This script reconstructs hydrogens from BLABLABLA...TODO"""def normalize(vec):    """Normalizes a vector.    Parameters    ----------    vec : numpy 1D-array.    Returns    -------    numpy 1D-array        The normalized vector.    """    nvec = vec / np.sqrt(np.sum(vec**2))    return nvecdef v2q(vec, theta):    """Translates a 3-D vector and angle theta in a quaternion.    Parameters    ----------    vec : numpy 1D-array        Vector of the quaternion.    theta : float        Angle of the quaternion in radian.    Returns    -------    numpy 1D-array        The full quaternion (4 elements).    """    w = np.cos(theta/2)    x, y, z = np.sin(theta/2)*normalize(vec)    q = np.array([w, x, y, z])    return qdef rotational_matrix(quaternion):    """Translates a quaternion to a rotational matrix.    Parameters    ----------    quaternion : numpy 1D-array of 4 elements.    Returns    -------    numpy 2D-array (dimension [3, 3])        The rotational matrix.    """    #init mat_rot np.array of dim 3,3 default values set to 0    mat_rot = np.zeros([3, 3])    w, x, y, z = quaternion    mat_rot[0,0] = w**2 + x**2 - y**2 - z**2    mat_rot[1,0] = 2*(x*y + w*z)    mat_rot[2,0] = 2*(x*z - w*y)    mat_rot[0,1] = 2*(x*y - w*z)    mat_rot[1,1] = w**2 - x**2 + y**2 - z**2    mat_rot[2,1] = 2*(y*z + w*x)    mat_rot[0,2] = 2*(x*z + w*y)    mat_rot[1,2] = 2*(y*z - w*x)    mat_rot[2,2] = w**2 - x**2 - y**2 + z**2    return mat_rotdef apply_rotation(vec_to_rotate, rotational_vector, rad_angle):    """Rotates a vector around another vector by a given angle.    Parameters    ----------    vec_to_rotate : numpy 1D-array.    vector to rotate around : numpy 1D-array.    rad_angle : float.    Returns    -------    numpy 1D-array        The final rotated (normalized) vector.    """    # Generate a quaternion of the given angle (in radian)    quat_rot = v2q(rotational_vector, rad_angle)    # Generate the rotational matrix     rot_mat_quat = rotational_matrix(quat_rot)    # Use the rotational matrix on the vector to rotate    vec_rotated = np.dot(rot_mat_quat, vec_to_rotate)    norm_vec = normalize(vec_rotated)    return norm_vecdef read_pdb(pdb_filename):    """Reads a PDB file and returns a pandas data frame.    Arguments    ---------    pdb_filename : string    Returns    -------    pandas dataframe        The col index are: atnum, atname, resname, resnum, x, y, z    """    rows = []    with open(pdb_filename, "r") as f:        for line in f:            if line.startswith("ATOM"):                atnum = int(line[6:11])                atname = line[12:16].strip()                resname = line[17:20].strip()                resnum = int(line[22:26])                x = float(line[30:38])                y = float(line[38:46])                z = float(line[46:54])                rows.append((atnum, atname, resname, resnum, x, y, z))    df_atoms = pd.DataFrame(rows, columns=["atnum", "atname", "resname",                                           "resnum", "x", "y", "z"])    return df_atomsdef write_PDB(atom_num, atom_type, coor):    """Prints atom coordinates in PDB format.    Parameters    ----------    atom_num : int    atom_type : string    coor : numpy 1D-array    Returns    -------    None    """    x, y, z = coor    # pdb format (source: http://cupnet.net/pdb-format/)    print("{:6s}{:5d} {:^4s}{:1s}{:3s} {:1s}{:4d}{:1s}   {:8.3f}{:8.3f}{:8.3f}"          "{:6.2f}{:6.2f}          {:>2s}{:2s}"          .format("ATOM", atom_num, atom_type, "", "POP", "", 1,"",  x, y, z,                  1.0, 0.0, "", ""))   def pandasdf2pdb(df):    """Returns a string from a pandas dataframe.    TODO    """    s = ""    chain = ""    for i, row_atom in df.iterrows():        atnum, atname, resname, resnum, x, y, z = row_atom        s += "{:6s}{:5d} {:^4s}{:1s}{:3s} {:1s}{:4d}{:1s}   {:8.3f}{:8.3f}{:8.3f}" \             "{:6.2f}{:6.2f}          {:>2s}{:2s}\n" \             .format("ATOM", atnum, atname, "", resname, chain, resnum, "",  x, y, z,                     1.0, 0.0, "", "")    return s     def get_SP2_H(atom, helper1, helper2):    """Reconstructs the 2 hydrogens of a SP2 carbon.    Parameters    ----------    atom : numpy 1D-array        Central atom on which we want to reconstruct hydrogens.    helper1 : numpy 1D-array        Heavy atom before central atom.    helper2 : numpy 1D-array        Heavy atom after central atom.    Returns    -------    tuple of numpy 1D-array        Coordinates of the two hydrogens:         ([x_H1, y_H1, z_H1], [x_H2, y_H2, z_H2]).    """    #atom - helper1 vector    v2 = normalize(helper1 - atom)    #atom - helper2 vector    v3 = normalize(helper2 - atom)    #####case(3) !CH2####    #Perpendicular to the helpers - atom plane    v4 = normalize(np.cross(v3, v2))    #Rotational vector    rot_vec = normalize(v2 - v3)    #Vector to be rotated by theta/2, perpendicular to rot_vec and v4    vec_to_rotate = normalize(np.cross(v4, rot_vec))    norm_vec_H1 = apply_rotation(vec_to_rotate, rot_vec, -1.911/2)    hcoor_H1 = 1 * norm_vec_H1 + atom    norm_vec_H2 = apply_rotation(vec_to_rotate, rot_vec, 1.911/2)    hcoor_H2 = 1 * norm_vec_H2 + atom    return (hcoor_H1, hcoor_H2)def get_name_H(name_carbon):    name_H1 = name_carbon.replace("C", "H") + "1"    name_H2 = name_carbon.replace("C", "H") + "2"    return name_H1, name_H2if __name__ == "__main__":    # read coordinates in a pandas dataframe    df_atoms = read_pdb("POPC_only.pdb")    # create an empty data frame to store the new mlc with added hydrogens    new_df_atoms = pd.DataFrame(columns=["atnum", "atname", "resname",                                 "resnum", "x", "y", "z"])    new_atom_num = 1    # loop over all existing atoms (the iter var row_atom is a pandas Series)    for i, row_atom in df_atoms.iterrows():        # add that atom to the new dataframe        new_atom = row_atom        new_atom["atnum"] = new_atom_num        new_atom.name = new_atom_num        new_df_atoms = new_df_atoms.append(new_atom)        new_atom_num += 1        # check whether it needs hydrogen(s) to be reconstructer        atom_name = row_atom["atname"]        if atom_name in dic_lipids.POPC:            # get atom info            atom_coor = np.array(row_atom[["x", "y", "z"]].values, dtype=float) # force to float            res_name, res_num = row_atom[["resname", "resnum"]]            # get helper atom names            helper1_name, helper2_name = dic_lipids.POPC[atom_name]            # get helper coords (needs [0] because it comes from a dataframe)            helper1_coor = df_atoms [ (df_atoms["resnum"] == res_num) &                                      (df_atoms["atname"] == helper1_name) ] \                                      [["x", "y", "z"]].values[0]            helper2_coor = df_atoms [ (df_atoms["resnum"] == res_num) &                                      (df_atoms["atname"] == helper2_name) ] \                                      [["x", "y", "z"]].values[0]            # construct H1 & H2            H1_coor, H2_coor = get_SP2_H(atom_coor, helper1_coor, helper2_coor)            H1_name, H2_name = get_name_H(atom_name)            # now create H1 & H2 as a pandas Series and append them into the new dataframe            H1_atom = pd.Series([new_atom_num, H1_name, res_name, res_num]                                + list(H1_coor),                                name = new_atom_num,                                index=["atnum", "atname", "resname", "resnum",                                       "x", "y", "z"])            new_df_atoms = new_df_atoms.append(H1_atom)            new_atom_num += 1               H2_atom = pd.Series([new_atom_num, H2_name, res_name, res_num]                                + list(H2_coor),                                name = new_atom_num,                                index=["atnum", "atname", "resname", "resnum",                                       "x", "y", "z"])            new_df_atoms = new_df_atoms.append(H2_atom)            new_atom_num += 1        #if i % 100 == 0:        #    print("Atom {:5d} done!".format(i))    #print(new_df_atoms)    print(pandasdf2pdb(new_df_atoms))    exit()    ##### OLD STUFF #######    for name_helper1, name_atom, name_helper2 in dic_lipids.POPC:        # select atom 2D-array (i.e. all atoms maching atom_name, thus dim = N*3)        atoms = df_atoms[ (df_atoms["resname"] == "POP") &                          (df_atoms["atname"] == name_atom) ] \                                 [["x", "y", "z"]].values        # select helper1 2D-array        helpers1 = df_atoms[ (df_atoms["resname"] == "POP") &                                 (df_atoms["atname"] == name_helper1) ] \                                 [["x", "y", "z"]].values        # select helper2 2D-array        helpers2 = df_atoms[ (df_atoms["resname"] == "POP") &                                 (df_atoms["atname"] == name_helper2) ] \                                 [["x", "y", "z"]].values        # loop over each triplet        for i in range(len(atoms)):            atom, helper1, helper2 = atoms[i], helpers1[i], helpers2[i]            #print(atom, helper1, helper2)            coor_H1, coor_H2 = get_SP2_H(atom, helper1, helper2)            name_H1, name_H2 = get_name_H(name_atom)            write_PDB(index, name_atom, atom)            index += 1            write_PDB(index, name_H1, coor_H1)            index += 1             write_PDB(index, name_H2, coor_H2)